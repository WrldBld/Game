//! DM Action Processor port - Interface for processing DM decisions
//!
//! This port abstracts DM action business logic from infrastructure workers.
//! The worker handles queue processing and broadcasting; this port handles
//! the actual action logic (approvals, scene transitions, event triggers, etc.)

use anyhow::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use wrldbldr_domain::{CharacterId, NarrativeEventId, SceneId, WorldId};

/// Result of processing a DM action
///
/// Each variant represents a different type of action outcome that the
/// infrastructure worker needs to handle (typically by broadcasting to clients).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DmActionResult {
    /// Approval decision was processed (approve/reject/edit)
    ///
    /// Contains messages that should be broadcast to players and/or DM.
    /// The worker is responsible for routing these appropriately.
    ApprovalProcessed {
        /// Messages to broadcast to players (e.g., DialogueResponse)
        broadcast_messages: Vec<serde_json::Value>,
        /// Optional feedback message for DM (e.g., rejection reason)
        dm_feedback: Option<String>,
    },

    /// Direct NPC dialogue was generated by DM override
    ///
    /// The DM has directly controlled an NPC, bypassing the LLM.
    /// This dialogue should be broadcast to all players.
    DialogueGenerated {
        /// The NPC character ID
        npc_id: CharacterId,
        /// The NPC's display name
        npc_name: String,
        /// The dialogue text to display
        dialogue: String,
    },

    /// Narrative event was triggered by DM
    ///
    /// The DM has manually triggered a narrative event.
    /// May include the outcome if the event has immediate effects.
    EventTriggered {
        /// The triggered event's ID
        event_id: NarrativeEventId,
        /// The event name (for logging/notification)
        event_name: String,
        /// Optional outcome description if event has immediate effects
        outcome: Option<String>,
    },

    /// Scene transition was completed
    ///
    /// The DM has transitioned the game to a new scene.
    /// Contains full scene data for broadcasting to all clients.
    SceneTransitioned {
        /// The new scene's ID
        scene_id: SceneId,
        /// Full scene data for the SceneUpdate message
        scene_data: serde_json::Value,
    },
}

/// Port for processing DM actions
///
/// This trait defines the interface for handling DM commands that affect
/// game state. Implementations should:
/// - Validate action parameters
/// - Update game state appropriately
/// - Return results for the worker to broadcast
///
/// The infrastructure worker is responsible for:
/// - Dequeuing actions from the DM action queue
/// - Calling this port to process each action
/// - Broadcasting results to appropriate clients
#[async_trait]
pub trait DmActionProcessorPort: Send + Sync {
    /// Process a DM action and return the result
    ///
    /// # Arguments
    /// * `action_type` - The type of action (e.g., "ApprovalDecision", "TriggerEvent")
    /// * `action_data` - JSON payload containing action-specific data
    /// * `world_id` - The world context for this action
    /// * `dm_user_id` - The user ID of the DM performing this action
    ///
    /// # Returns
    /// * `Ok(DmActionResult)` - The result to be broadcast by the worker
    /// * `Err(_)` - Processing failed; worker should log and potentially retry
    ///
    /// # Action Types
    /// - `ApprovalDecision`: Process approve/reject/edit of pending approval
    /// - `DirectNPCControl`: DM directly controls NPC dialogue
    /// - `TriggerEvent`: Manually trigger a narrative event
    /// - `TransitionScene`: Transition to a new scene
    async fn process_action(
        &self,
        action_type: &str,
        action_data: serde_json::Value,
        world_id: WorldId,
        dm_user_id: &str,
    ) -> Result<DmActionResult>;
}
